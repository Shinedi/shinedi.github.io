<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue-print5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/27/vue-print5/" class="article-date">
  <time datetime="2020-10-27T10:20:53.000Z" itemprop="datePublished">2020-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/27/vue-print5/">vue-print5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><hr>
<p>Vue 的<code>_render</code>方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 <code>src/core/instance/render.js</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">  const vm: Component &#x3D; this</span><br><span class="line">  const &#123; render, _parentVnode &#125; &#x3D; vm.$options</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; reset _rendered flag on slots for duplicate slot check</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    for (const key in vm.$slots) &#123;</span><br><span class="line">      &#x2F;&#x2F; $flow-disable-line</span><br><span class="line">      vm.$slots[key]._rendered &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (_parentVnode) &#123;</span><br><span class="line">    vm.$scopedSlots &#x3D; _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; set parent vnode. this allows render functions to have access</span><br><span class="line">  &#x2F;&#x2F; to the data on the placeholder node.</span><br><span class="line">  vm.$vnode &#x3D; _parentVnode</span><br><span class="line">  &#x2F;&#x2F; render self</span><br><span class="line">  let vnode</span><br><span class="line">  try &#123;</span><br><span class="line">    vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    handleError(e, vm, &#96;render&#96;)</span><br><span class="line">    &#x2F;&#x2F; return error render result,</span><br><span class="line">    &#x2F;&#x2F; or previous vnode to prevent render error causing blank component</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      if (vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode &#x3D; vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, &#96;renderError&#96;)</span><br><span class="line">          vnode &#x3D; vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode &#x3D; vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vnode &#x3D; vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; return empty vnode in case the render function errored out</span><br><span class="line">  if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &#39;Multiple root nodes returned from render function. Render function &#39; +</span><br><span class="line">        &#39;should return a single root node.&#39;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vnode &#x3D; createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; set parent</span><br><span class="line">  vnode.parent &#x3D; _parentVnode</span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码最关键的是 <code>render</code> 方法的调用，我们在平时的开发工作中手写 <code>render</code> 方法的场景比较少，而写的比较多的是 <code>template</code> 模板，在之前的 <code>mounted</code>方法的实现中，会把 <code>template</code>编译成 <code>render</code>方法，但这个编译过程是非常复杂的，我们不打算在这里展开讲，之后会专门花一个章节来分析 Vue 的编译过程。</p>
<p>在 Vue 的官方文档中介绍了<code>render</code>函数的第一个参数是 <code>createElement</code>，那么结合之前的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>相当于我们编写如下<code>render</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: function (createElement) &#123;</span><br><span class="line">  return createElement(&#39;div&#39;, &#123;</span><br><span class="line">     attrs: &#123;</span><br><span class="line">        id: &#39;app&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;, this.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到 <code>_render</code> 函数中的 <code>render</code> 方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode &#x3D; render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>render</code> 函数中的 <code>createElement</code> 方法就是 <code>vm.$createElement</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function initRender (vm: Component) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; bind the createElement fn to this instance</span><br><span class="line">  &#x2F;&#x2F; so that we get proper render context inside it.</span><br><span class="line">  &#x2F;&#x2F; args order: tag, data, children, normalizationType, alwaysNormalize</span><br><span class="line">  &#x2F;&#x2F; internal version is used by render functions compiled from templates</span><br><span class="line">  vm._c &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, false)</span><br><span class="line">  &#x2F;&#x2F; normalization is always applied for the public version, used in</span><br><span class="line">  &#x2F;&#x2F; user-written render functions.</span><br><span class="line">  vm.$createElement &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>vm.$createElement</code> 方法定义是在执行 <code>initRender</code> 方法的时候，可以看到除了 <code>vm.$createElement</code> 方法，还有一个 <code>vm._c</code> 方法，它是被模板编译成的<code>render</code>函数使用，而<code>vm.$createElement</code>是用户手写 <code>render</code> 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 <code>createElement</code> 方法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<figure class="highlight plain"><figcaption><span>最终是通过执行 ```createElement ```方法并返回的是 ```vnode```，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 ```createElement``` 的实现前，我们先了解一下 Virtual DOM 的概念。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### Virtual DOM</span><br><span class="line"></span><br><span class="line">Virtual DOM 这个概念相信大部分人都不会陌生，它产生的前提是浏览器中的 DOM 是很“昂贵&quot;的，为了更直观的感受，我们可以简单的把一个简单的 div 元素的属性都打印出来，</span><br></pre></td></tr></table></figure>
<p>var div=document.createElement(‘div’);<br>var str=’’;<br>for(var key in div){str+=key+’’}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到，真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。</span><br><span class="line"></span><br><span class="line">而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 &#96;&#96;&#96;src&#x2F;core&#x2F;vdom&#x2F;vnode.js&#96;&#96;&#96; 中的。</span><br></pre></td></tr></table></figure>
<p>export default class VNode {<br>  tag: string | void;<br>  data: VNodeData | void;<br>  children: ?Array<VNode>;<br>  text: string | void;<br>  elm: Node | void;<br>  ns: string | void;<br>  context: Component | void; // rendered in this component’s scope<br>  key: string | number | void;<br>  componentOptions: VNodeComponentOptions | void;<br>  componentInstance: Component | void; // component instance<br>  parent: VNode | void; // component placeholder node</p>
<p>  // strictly internal<br>  raw: boolean; // contains raw HTML? (server only)<br>  isStatic: boolean; // hoisted static node<br>  isRootInsert: boolean; // necessary for enter transition check<br>  isComment: boolean; // empty comment placeholder?<br>  isCloned: boolean; // is a cloned node?<br>  isOnce: boolean; // is a v-once node?<br>  asyncFactory: Function | void; // async component factory function<br>  asyncMeta: Object | void;<br>  isAsyncPlaceholder: boolean;<br>  ssrContext: Object | void;<br>  fnContext: Component | void; // real context vm for functional nodes<br>  fnOptions: ?ComponentOptions; // for SSR caching<br>  fnScopeId: ?string; // functional scope id support</p>
<p>  constructor (<br>    tag?: string,<br>    data?: VNodeData,<br>    children?: ?Array<VNode>,<br>    text?: string,<br>    elm?: Node,<br>    context?: Component,<br>    componentOptions?: VNodeComponentOptions,<br>    asyncFactory?: Function<br>  ) {<br>    this.tag = tag<br>    this.data = data<br>    this.children = children<br>    this.text = text<br>    this.elm = elm<br>    this.ns = undefined<br>    this.context = context<br>    this.fnContext = undefined<br>    this.fnOptions = undefined<br>    this.fnScopeId = undefined<br>    this.key = data &amp;&amp; data.key<br>    this.componentOptions = componentOptions<br>    this.componentInstance = undefined<br>    this.parent = undefined<br>    this.raw = false<br>    this.isStatic = false<br>    this.isRootInsert = true<br>    this.isComment = false<br>    this.isCloned = false<br>    this.isOnce = false<br>    this.asyncFactory = asyncFactory<br>    this.asyncMeta = undefined<br>    this.isAsyncPlaceholder = false<br>  }</p>
<p>  // DEPRECATED: alias for componentInstance for backwards compat.<br>  /* istanbul ignore next */<br>  get child (): Component | void {<br>    return this.componentInstance<br>  }<br>}</p>
<p>```</p>
<p>可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为它这里包含了很多 Vue.js 的特性。这里千万不要被这些茫茫多的属性吓到，实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西。我建议大家如果想深入了解 Vue.js 的 Virtual DOM 前不妨先阅读这个库的源码，因为它更加简单和纯粹。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><hr>
<p>其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。</p>
<p>Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 <code>createElement</code>方法创建的，我们接下来分析这部分的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/27/vue-print5/" data-id="ckgrz36er000035l23jncepm5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-prin4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/26/vue-prin4/" class="article-date">
  <time datetime="2020-10-26T13:03:43.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/26/vue-prin4/">vue-prin4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Vue-实例挂载的实现"><a href="#Vue-实例挂载的实现" class="headerlink" title="Vue 实例挂载的实现"></a>Vue 实例挂载的实现</h4><hr>
<p>Vue 中我们是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的，<code>$mount</code> 方法在多个文件中都有定义，如 <code>src/platform/web/entry-runtime-with-compiler.js</code>、<code>src/platform/web/runtime/index.js</code>、<code>src/platform/weex/runtime/index.js</code>。因为 <code>$mount</code>这个方法的实现是和平台、构建方式都相关的。接下来我们重点分析带 <code>compiler</code> 版本的 <code>$mount</code> 实现，因为抛开 webpack 的 vue-loader，我们在纯前端浏览器环境分析 Vue 的工作原理，有助于我们对原理理解的深入。</p>
<figure class="highlight plain"><figcaption><span>版本的``` $mount``` 实现非常有意思，先来看一下 ```src/platform/web/entry-runtime-with-compiler.js``` 文件中定义：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">const mount &#x3D; Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (el &#x3D;&#x3D;&#x3D; document.body || el &#x3D;&#x3D;&#x3D; document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">      &#96;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&#96;</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  &#x2F;&#x2F; resolve template&#x2F;el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template &#x3D; options.template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        if (template.charAt(0) &#x3D;&#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">          template &#x3D; idToTemplate(template)</span><br><span class="line">          &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">          if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              &#96;Template element not found or is empty: $&#123;options.template&#125;&#96;,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template &#x3D; template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          warn(&#39;invalid template option:&#39; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template &#x3D; getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render &#x3D; render</span><br><span class="line">      options.staticRenderFns &#x3D; staticRenderFns</span><br><span class="line"></span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile end&#39;)</span><br><span class="line">        measure(&#96;vue $&#123;this._name&#125; compile&#96;, &#39;compile&#39;, &#39;compile end&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先缓存了原型上的 <code>$mount</code> 方法，再重新定义该方法，我们先来分析这段代码。首先，它对 <code>el</code> 做了限制，Vue 不能挂载在 <code>body</code>、<code>html</code>这样的根节点上。接下来的是很关键的逻辑 —— 如果没有定义 <code>render</code> 方法，则会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code>方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 <code>render</code> 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 <code>el</code> 或者 <code>template</code> 属性，最终都会转换成 <code>render</code> 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 <code>compileToFunctions</code> 方法实现的，编译过程我们之后会介绍。最后，调用原先原型上的 <code>$mount</code> 方法挂载。</p>
<p>原先原型上的 <code>$mount</code> 方法在 <code>src/platform/web/runtime/index.js</code> 中定义，之所以这么设计完全是为了复用，因为它是可以被 <code>runtime only</code> 版本的 Vue 直接使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; public mount method</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>方法支持传入 2 个参数，第一个是 ```el```，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 ```query``` 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;$mount&#96;&#96;&#96; 方法实际上会去调用 &#96;&#96;&#96;mountComponent&#96;&#96;&#96; 方法，这个方法定义在 &#96;&#96;&#96;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js&#96;&#96;&#96; 文件中：</span><br></pre></td></tr></table></figure>
<p>export function mountComponent (<br>  vm: Component,<br>  el: ?Element,<br>  hydrating?: boolean<br>): Component {<br>  vm.$el = el<br>  if (!vm.$options.render) {<br>    vm.$options.render = createEmptyVNode<br>    if (process.env.NODE_ENV !== ‘production’) {<br>      /* istanbul ignore if */<br>      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== ‘#’) ||<br>        vm.$options.el || el) {<br>        warn(<br>          ‘You are using the runtime-only build of Vue where the template ‘ +<br>          ‘compiler is not available. Either pre-compile the templates into ‘ +<br>          ‘render functions, or use the compiler-included build.’,<br>          vm<br>        )<br>      } else {<br>        warn(<br>          ‘Failed to mount component: template or render function not defined.’,<br>          vm<br>        )<br>      }<br>    }<br>  }<br>  callHook(vm, ‘beforeMount’)</p>
<p>  let updateComponent<br>  /* istanbul ignore if */<br>  if (process.env.NODE_ENV !== ‘production’ &amp;&amp; config.performance &amp;&amp; mark) {<br>    updateComponent = () =&gt; {<br>      const name = vm._name<br>      const id = vm._uid<br>      const startTag = <code>vue-perf-start:${id}</code><br>      const endTag = <code>vue-perf-end:${id}</code></p>
<pre><code>  mark(startTag)
  const vnode = vm._render()
  mark(endTag)
  measure(`vue ${name} render`, startTag, endTag)

  mark(startTag)
  vm._update(vnode, hydrating)
  mark(endTag)
  measure(`vue ${name} patch`, startTag, endTag)
}</code></pre><p>  } else {<br>    updateComponent = () =&gt; {<br>      vm._update(vm._render(), hydrating)<br>    }<br>  }</p>
<p>  // we set this to vm._watcher inside the watcher’s constructor<br>  // since the watcher’s initial patch may call $forceUpdate (e.g. inside child<br>  // component’s mounted hook), which relies on vm._watcher being already defined<br>  new Watcher(vm, updateComponent, noop, {<br>    before () {<br>      if (vm._isMounted) {<br>        callHook(vm, ‘beforeUpdate’)<br>      }<br>    }<br>  }, true /* isRenderWatcher */)<br>  hydrating = false</p>
<p>  // manually mounted instance, call mounted on self<br>  // mounted is called for render-created child components in its inserted hook<br>  if (vm.$vnode == null) {<br>    vm._isMounted = true<br>    callHook(vm, ‘mounted’)<br>  }<br>  return vm<br>}</p>
<pre><code>
从上面的代码可以看到，```mountComponent ```核心就是先实例化一个渲染```Watcher```，在它的回调函数中会调用 ```updateComponent``` 方法，在此方法中调用 ```vm._render``` 方法先生成虚拟 Node，最终调用 ```vm._update``` 更新 DOM。

```Watcher``` 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。

函数最后判断为根节点的时候设置 ```vm._isMounted``` 为 ```true```， 表示这个实例已经挂载了，同时执行 ```mounted``` 钩子函数。 这里注意 ```vm.$vnode ```表示 Vue 实例的父虚拟 Node，所以它为 ```Null```则表示当前是根 Vue 的实例。

#### 总结
---
```mountComponent``` 方法的逻辑也是非常清晰的，它会完成整个渲染工作，接下来我们要重点分析其中的细节，也就是最核心的 2 个方法：```vm._render``` 和 ```vm._update```。


</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/26/vue-prin4/" data-id="ckgqk9clf00001el2fq2r6ns1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-prin3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/22/vue-prin3/" class="article-date">
  <time datetime="2020-10-22T12:17:51.000Z" itemprop="datePublished">2020-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/22/vue-prin3/">vue-prin3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h4><hr>
<p>Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。</p>
<p>在 Vue.js 中我们可以采用简洁的模板语法来声明式的将数据渲染为 DOM：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>数据驱动还有一部分是数据更新驱动视图变化</p>
<h4 id="new-Vue-发生了什么"><a href="#new-Vue-发生了什么" class="headerlink" title="new Vue 发生了什么"></a>new Vue 发生了什么</h4><hr>
<p>从入口代码开始分析，我们先来分析 <code>new Vue</code> 背后发生了哪些事情。我们都知道，<code>new</code> 关键字在 Javascript 语言中代表实例化是一个对象，而 Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在<code>src/core/instance/index.js</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>Vue</code> 只能通过 new 关键字初始化，然后会调用 <code>this._init</code> 方法， 该方法在 <code>src/core/instance/init.js</code> 中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init &#x3D; function (options?: Object) &#123;</span><br><span class="line">  const vm: Component &#x3D; this</span><br><span class="line">  &#x2F;&#x2F; a uid</span><br><span class="line">  vm._uid &#x3D; uid++</span><br><span class="line"></span><br><span class="line">  let startTag, endTag</span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag &#x3D; &#96;vue-perf-start:$&#123;vm._uid&#125;&#96;</span><br><span class="line">    endTag &#x3D; &#96;vue-perf-end:$&#123;vm._uid&#125;&#96;</span><br><span class="line">    mark(startTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; a flag to avoid this being observed</span><br><span class="line">  vm._isVue &#x3D; true</span><br><span class="line">  &#x2F;&#x2F; merge options</span><br><span class="line">  if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    &#x2F;&#x2F; optimize internal component instantiation</span><br><span class="line">    &#x2F;&#x2F; since dynamic options merging is pretty slow, and none of the</span><br><span class="line">    &#x2F;&#x2F; internal component options needs special treatment.</span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vm.$options &#x3D; mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vm._renderProxy &#x3D; vm</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; expose real self</span><br><span class="line">  vm._self &#x3D; vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, &#39;beforeCreate&#39;)</span><br><span class="line">  initInjections(vm) &#x2F;&#x2F; resolve injections before data&#x2F;props</span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) &#x2F;&#x2F; resolve provide after data&#x2F;props</span><br><span class="line">  callHook(vm, &#39;created&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    vm._name &#x3D; formatComponentName(vm, false)</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(&#96;vue $&#123;vm._name&#125; init&#96;, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<p>Vue 的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。</p>
<p>由于我们先弄清楚模板和数据如何渲染成最终的 DOM，所以各种初始化逻辑我们先不看。在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/22/vue-prin3/" data-id="ckgkstx0k0000bnl27thbhzw7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-prin2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/21/vue-prin2/" class="article-date">
  <time datetime="2020-10-21T12:30:18.000Z" itemprop="datePublished">2020-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/21/vue-prin2/">vue-prin2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h4><hr>
<p>我们之前提到过 Vue.js 构建过程，在 web 应用下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 <code>src/platforms/web/entry-runtime-with-compiler.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @flow *&#x2F;</span><br><span class="line"></span><br><span class="line">import config from &#39;core&#x2F;config&#39;</span><br><span class="line">import &#123; warn, cached &#125; from &#39;core&#x2F;util&#x2F;index&#39;</span><br><span class="line">import &#123; mark, measure &#125; from &#39;core&#x2F;util&#x2F;perf&#39;</span><br><span class="line"></span><br><span class="line">import Vue from &#39;.&#x2F;runtime&#x2F;index&#39;</span><br><span class="line">import &#123; query &#125; from &#39;.&#x2F;util&#x2F;index&#39;</span><br><span class="line">import &#123; compileToFunctions &#125; from &#39;.&#x2F;compiler&#x2F;index&#39;</span><br><span class="line">import &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref &#125; from &#39;.&#x2F;util&#x2F;compat&#39;</span><br><span class="line"></span><br><span class="line">const idToTemplate &#x3D; cached(id &#x3D;&gt; &#123;</span><br><span class="line">  const el &#x3D; query(id)</span><br><span class="line">  return el &amp;&amp; el.innerHTML</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const mount &#x3D; Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">  if (el &#x3D;&#x3D;&#x3D; document.body || el &#x3D;&#x3D;&#x3D; document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">      &#96;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&#96;</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  &#x2F;&#x2F; resolve template&#x2F;el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template &#x3D; options.template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">        if (template.charAt(0) &#x3D;&#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">          template &#x3D; idToTemplate(template)</span><br><span class="line">          &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">          if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              &#96;Template element not found or is empty: $&#123;options.template&#125;&#96;,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template &#x3D; template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          warn(&#39;invalid template option:&#39; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template &#x3D; getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render &#x3D; render</span><br><span class="line">      options.staticRenderFns &#x3D; staticRenderFns</span><br><span class="line"></span><br><span class="line">      &#x2F;* istanbul ignore if *&#x2F;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#39;compile end&#39;)</span><br><span class="line">        measure(&#96;vue $&#123;this._name&#125; compile&#96;, &#39;compile&#39;, &#39;compile end&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Get outerHTML of elements, taking care</span><br><span class="line"> * of SVG elements in IE as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">function getOuterHTML (el: Element): string &#123;</span><br><span class="line">  if (el.outerHTML) &#123;</span><br><span class="line">    return el.outerHTML</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const container &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    container.appendChild(el.cloneNode(true))</span><br><span class="line">    return container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.compile &#x3D; compileToFunctions</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>

<p>那么，当我们的代码执行 <code>import Vue from &#39;vue&#39;</code> 的时候，就是从这个入口执行代码来初始化 Vue， 那么 Vue 到底是什么，它是怎么初始化的，我们来一探究竟。</p>
<h4 id="Vue-的入口"><a href="#Vue-的入口" class="headerlink" title="Vue 的入口"></a>Vue 的入口</h4><hr>
<p>在这个入口 JS 的上方我们可以找到 <code>Vue</code> 的来源：<code>import Vue from &#39;./runtime/index</code>，我们先来看一下这块儿的实现，它定义在 <code>src/platforms/web/runtime/index.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;core&#x2F;index&#39;</span><br><span class="line">import config from &#39;core&#x2F;config&#39;</span><br><span class="line">import &#123; extend, noop &#125; from &#39;shared&#x2F;util&#39;</span><br><span class="line">import &#123; mountComponent &#125; from &#39;core&#x2F;instance&#x2F;lifecycle&#39;</span><br><span class="line">import &#123; devtools, inBrowser, isChrome &#125; from &#39;core&#x2F;util&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">  query,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  isReservedAttr,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  isUnknownElement</span><br><span class="line">&#125; from &#39;web&#x2F;util&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">import &#123; patch &#125; from &#39;.&#x2F;patch&#39;</span><br><span class="line">import platformDirectives from &#39;.&#x2F;directives&#x2F;index&#39;</span><br><span class="line">import platformComponents from &#39;.&#x2F;components&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; install platform specific utils</span><br><span class="line">Vue.config.mustUseProp &#x3D; mustUseProp</span><br><span class="line">Vue.config.isReservedTag &#x3D; isReservedTag</span><br><span class="line">Vue.config.isReservedAttr &#x3D; isReservedAttr</span><br><span class="line">Vue.config.getTagNamespace &#x3D; getTagNamespace</span><br><span class="line">Vue.config.isUnknownElement &#x3D; isUnknownElement</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; install platform runtime directives &amp; components</span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; install platform patch function</span><br><span class="line">Vue.prototype.__patch__ &#x3D; inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; public mount method</span><br><span class="line">Vue.prototype.$mount &#x3D; function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
<p>这里关键的代码是 <code>import Vue from &#39;core/index</code>，之后的逻辑都是对 Vue 这个对象做一些扩展，可以先不用看，我们来看一下真正初始化 Vue 的地方，在 <code>src/core/index.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;.&#x2F;instance&#x2F;index&#39;</span><br><span class="line">import &#123; initGlobalAPI &#125; from &#39;.&#x2F;global-api&#x2F;index&#39;</span><br><span class="line">import &#123; isServerRendering &#125; from &#39;core&#x2F;util&#x2F;env&#39;</span><br><span class="line">import &#123; FunctionalRenderContext &#125; from &#39;core&#x2F;vdom&#x2F;create-functional-component&#39;</span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Vue.prototype, &#39;$isServer&#39;, &#123;</span><br><span class="line">  get: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Vue.prototype, &#39;$ssrContext&#39;, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    &#x2F;* istanbul ignore next *&#x2F;</span><br><span class="line">    return this.$vnode &amp;&amp; this.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expose FunctionalRenderContext for ssr runtime helper installation</span><br><span class="line">Object.defineProperty(Vue, &#39;FunctionalRenderContext&#39;, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version &#x3D; &#39;__VERSION__&#39;</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
<p>这里有 2 处关键的代码，<code>import Vue from &#39;./instance/index&#39;</code> 和 <code>initGlobalAPI(Vue)</code>，初始化全局 Vue API（我们稍后介绍），我们先来看第一部分，在 <code>src/core/instance/index.js</code> 中：</p>
<h4 id="Vue的定义"><a href="#Vue的定义" class="headerlink" title="Vue的定义"></a>Vue的定义</h4><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &#39;.&#x2F;init&#39;</span><br><span class="line">import &#123; stateMixin &#125; from &#39;.&#x2F;state&#39;</span><br><span class="line">import &#123; renderMixin &#125; from &#39;.&#x2F;render&#39;</span><br><span class="line">import &#123; eventsMixin &#125; from &#39;.&#x2F;events&#39;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &#39;.&#x2F;lifecycle&#39;</span><br><span class="line">import &#123; warn &#125; from &#39;..&#x2F;util&#x2F;index&#39;</span><br><span class="line"></span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#39;Vue is a constructor and should be called with the &#96;new&#96; keyword&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure>
<p>在这里，我们终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过<code>new Vue</code> 去实例化它。</p>
<p>其实就是使用原型对象<a href="https://segmentfault.com/a/1190000008338987" target="_blank" rel="noopener">深入理解 JavaScript 中的 class</a></p>
<p>有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 <code>xxxMixin</code> 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法（这里具体的细节会在之后的文章介绍，这里不展开），Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p>
<h4 id="initGlobalAPI"><a href="#initGlobalAPI" class="headerlink" title="initGlobalAPI"></a>initGlobalAPI</h4><hr>
<p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export function initGlobalAPI (Vue: GlobalAPI) &#123;</span><br><span class="line">  &#x2F;&#x2F; config</span><br><span class="line">  const configDef &#x3D; &#123;&#125;</span><br><span class="line">  configDef.get &#x3D; () &#x3D;&gt; config</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    configDef.set &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &#39;Do not replace the Vue.config object, set individual fields instead.&#39;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(Vue, &#39;config&#39;, configDef)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; exposed util methods.</span><br><span class="line">  &#x2F;&#x2F; NOTE: these are not considered part of the public API - avoid relying on</span><br><span class="line">  &#x2F;&#x2F; them unless you are aware of the risk.</span><br><span class="line">  Vue.util &#x3D; &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.set &#x3D; set</span><br><span class="line">  Vue.delete &#x3D; del</span><br><span class="line">  Vue.nextTick &#x3D; nextTick</span><br><span class="line"></span><br><span class="line">  Vue.options &#x3D; Object.create(null)</span><br><span class="line">  ASSET_TYPES.forEach(type &#x3D;&gt; &#123;</span><br><span class="line">    Vue.options[type + &#39;s&#39;] &#x3D; Object.create(null)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; this is used to identify the &quot;base&quot; constructor to extend all plain-object</span><br><span class="line">  &#x2F;&#x2F; components with in Weex&#39;s multi-instance scenarios.</span><br><span class="line">  Vue.options._base &#x3D; Vue</span><br><span class="line"></span><br><span class="line">  extend(Vue.options.components, builtInComponents)</span><br><span class="line"></span><br><span class="line">  initUse(Vue)</span><br><span class="line">  initMixin(Vue)</span><br><span class="line">  initExtend(Vue)</span><br><span class="line">  initAssetRegisters(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到，这里不会介绍细节，会在之后的章节我们具体介绍到某个 API 的时候会详细介绍。有一点要注意的是，<code>Vue.util</code> 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<p><code>Vue</code>本质上就是一个用 Function 实现的 Class，然后它的原型 prototype 以及它本身都扩展了一系列的方法和属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/21/vue-prin2/" data-id="ckgje1k5a00000kl21ybu22ws" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-prin1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/19/vue-prin1/" class="article-date">
  <time datetime="2020-10-19T12:15:39.000Z" itemprop="datePublished">2020-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/19/vue-prin1/">vue-prin1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####1、 了解flow<br>静态语法校验</p>
<ul>
<li>安装： npm i -g flow-bin</li>
<li>生成.flowconfig文件： flow init</li>
<li>在要检查类型的文件里加入/<em>@flow</em>/,才会对这个文件进行类型检查<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*@flow*&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*@flow*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* function splits(str) &#123;</span><br><span class="line">    return str.split(&#39; &#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">splits(11) *&#x2F;</span><br><span class="line"></span><br><span class="line">function add (x: number, y: number):number &#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(12, 11)</span><br><span class="line"></span><br><span class="line">var arr: Array&lt;number&gt; &#x3D; [1,2,3];</span><br><span class="line">arr.push(1)</span><br><span class="line"></span><br><span class="line">class Bar &#123;</span><br><span class="line">    x: string;</span><br><span class="line">    y: string | number | void;</span><br><span class="line">    z: boolean;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x &#x3D; x</span><br><span class="line">        this.y &#x3D; y</span><br><span class="line">        this.z &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar: Bar &#x3D; new Bar(&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line">var obj: &#123;a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; &#x3D; &#123;</span><br><span class="line">    a: &#39;hello&#39;,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: [&#39;hello&#39;, &#39;world&#39;],</span><br><span class="line">    d: new Bar(&#39;hello&#39;, 3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在命令行工具里输入flow来输出检查结果</li>
</ul>
<h4 id="2、Vue-js源码构建"><a href="#2、Vue-js源码构建" class="headerlink" title="2、Vue.js源码构建"></a>2、Vue.js源码构建</h4><p>Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。</p>
<ul>
<li><h5 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h5>通常一个基于 NPM 托管的项目都会有一个 package.json 文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;node scripts&#x2F;build.js&quot;,</span><br><span class="line">    &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;,</span><br><span class="line">    &quot;build:weex&quot;: &quot;npm run build -- weex&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h5>我们对于构建过程分析是基于源码的，先打开构建的入口 JS 文件，在 scripts/build.js 中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let builds &#x3D; require(&#39;.&#x2F;config&#39;).getAllBuilds()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filter builds via command line arg</span><br><span class="line">if (process.argv[2]) &#123;</span><br><span class="line">  const filters &#x3D; process.argv[2].split(&#39;,&#39;)</span><br><span class="line">  builds &#x3D; builds.filter(b &#x3D;&gt; &#123;</span><br><span class="line">    return filters.some(f &#x3D;&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; filter out weex builds by default</span><br><span class="line">  builds &#x3D; builds.filter(b &#x3D;&gt; &#123;</span><br><span class="line">    return b.output.file.indexOf(&#39;weex&#39;) &#x3D;&#x3D;&#x3D; -1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build(builds)</span><br></pre></td></tr></table></figure>
先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。接下来我们看一下配置文件，在 scripts/config.js 中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const builds &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span><br><span class="line">  &#39;web-runtime-cjs&#39;: &#123;</span><br><span class="line">    entry: resolve(&#39;web&#x2F;entry-runtime.js&#39;),</span><br><span class="line">    dest: resolve(&#39;dist&#x2F;vue.runtime.common.js&#39;),</span><br><span class="line">    format: &#39;cjs&#39;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; Runtime+compiler CommonJS build (CommonJS)</span><br><span class="line">  &#39;web-full-cjs&#39;: &#123;</span><br><span class="line">    entry: resolve(&#39;web&#x2F;entry-runtime-with-compiler.js&#39;),</span><br><span class="line">    dest: resolve(&#39;dist&#x2F;vue.common.js&#39;),</span><br><span class="line">    format: &#39;cjs&#39;,</span><br><span class="line">    alias: &#123; he: &#39;.&#x2F;entity-decoder&#39; &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于单个配置，它是遵循 Rollup 的构建规则的。其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的 JS 文件地址。format 属性表示构建的格式，cjs 表示构建出来的文件遵循 CommonJS 规范，es 表示构建出来的文件遵循 ES Module 规范。 umd 表示构建出来的文件遵循 UMD 规范。</li>
</ul>
<p>以 <code>web-runtime-cjs</code>配置为例，它的 entry 是 <code>resolve(&#39;web/entry-runtime.js&#39;)</code>，先来看一下 resolve 函数的定义。</p>
<p>源码目录：<code>scripts/config.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const aliases &#x3D; require(&#39;.&#x2F;alias&#39;)</span><br><span class="line">const resolve &#x3D; p &#x3D;&gt; &#123;</span><br><span class="line">  const base &#x3D; p.split(&#39;&#x2F;&#39;)[0]</span><br><span class="line">  if (aliases[base]) &#123;</span><br><span class="line">    return path.resolve(aliases[base], p.slice(base.length + 1))</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return path.resolve(__dirname, &#39;..&#x2F;&#39;, p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>resolve</code>函数实现非常简单，它先把 <code>resolve</code> 函数传入的参数 <code>p</code>通过<code>/</code>做了分割成数组，然后取数组第一个元素设置为 <code>base</code>。在我们这个例子中，参数 <code>p</code> 是 <code>web/entry-runtime.js</code>，那么 <code>base</code> 则为 <code>web</code>。<code>base</code> 并不是实际的路径，它的真实路径借助了别名的配置，我们来看一下别名配置的代码，在 <code>scripts/alias</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  vue: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler&#39;),</span><br><span class="line">  compiler: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;compiler&#39;),</span><br><span class="line">  core: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;core&#39;),</span><br><span class="line">  shared: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;shared&#39;),</span><br><span class="line">  web: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;platforms&#x2F;web&#39;),</span><br><span class="line">  weex: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;platforms&#x2F;weex&#39;),</span><br><span class="line">  server: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;server&#39;),</span><br><span class="line">  entries: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;entries&#39;),</span><br><span class="line">  sfc: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;sfc&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这里 <code>web</code> 对应的真实的路径是 <code>path.resolve(__dirname, &#39;../src/platforms/web&#39;)</code>，这个路径就找到了 Vue.js 源码的 web 目录。然后 <code>resolve</code> 函数通过 <code>path.resolve(aliases[base], p.slice(base.length + 1))</code> 找到了最终路径，它就是 Vue.js 源码 web 目录下的 <code>entry-runtime.js</code>。因此，<code>web-runtime-cjs</code> 配置对应的入口文件就找到了。</p>
<p>它经过 Rollup 的构建打包后，最终会在 dist 目录下生成 <code>vue.runtime.common.js</code>。</p>
<h4 id="3、Runtime-Only-VS-Runtime-Compiler"><a href="#3、Runtime-Only-VS-Runtime-Compiler" class="headerlink" title="3、Runtime Only VS Runtime + Compiler"></a>3、Runtime Only VS Runtime + Compiler</h4><p>通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本。</p>
<ul>
<li>Runtime Only<br>我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。</li>
<li>Runtime + Compiler<br>我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要编译器的版本</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  template: &#39;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这种情况不需要</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    return h(&#39;div&#39;, this.hi)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
因为在 Vue.js 2.0 中，最终渲染都是通过 <code>render</code> 函数，如果写 <code>template</code> 属性，则需要编译成 <code>render</code> 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</li>
</ul>
<p>很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/19/vue-prin1/" data-id="ckggickwg000082l22eb97rp3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-924" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/24/vue-924/" class="article-date">
  <time datetime="2020-09-24T03:45:35.000Z" itemprop="datePublished">2020-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/24/vue-924/">vue-924</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、vue-lazyload"><a href="#1、vue-lazyload" class="headerlink" title="1、vue-lazyload"></a>1、vue-lazyload</h4><p>图片过多时，可以使用vue-lazyload库进行懒加载</p>
<ul>
<li>npm i vue-lazyload<br>main.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import VueLazyLoad from &#39;vue-lazy-load&#39;</span><br><span class="line">Vue.use(VueLazyLoad, &#123;</span><br><span class="line">    default: &#39;默认图片&#39; &#x2F;&#x2F; 在图片没加载时，显示默认图片</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-lazy&#x3D;&quot;link&quot;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、获取html里面的属性"><a href="#2、获取html里面的属性" class="headerlink" title="2、获取html里面的属性"></a>2、获取html里面的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;singer&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;singer&quot; v-for&#x3D;&quot;(item, index) in singers&quot; @touchstart&#x3D;&quot;touchEvent&quot;   data-index&#x3D;&quot;index&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">...</span><br><span class="line">touchEvent(e)&#123;</span><br><span class="line">    let index &#x3D; e.target.getAttribute(&#39;data-index&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取touchs的pageY<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let firstTouch &#x3D; e.touchs[0];</span><br><span class="line">this.touch.y2 &#x3D; firstTouch.pageY;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、页面A里面添加子路由"><a href="#3、页面A里面添加子路由" class="headerlink" title="3、页面A里面添加子路由"></a>3、页面A里面添加子路由</h4><ul>
<li>router/index.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;singer&#39;,</span><br><span class="line">    component: Singer,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#39;:id&#39;,</span><br><span class="line">            component: SingerDetail</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>页面A<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">selectSinger (singer) &#123;</span><br><span class="line">   this.$router.push(&#123;</span><br><span class="line">   path: &#96;&#x2F;singer&#x2F;$&#123;singer.id&#125;&#96;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、Vuex-是什么"><a href="#4、Vuex-是什么" class="headerlink" title="4、Vuex 是什么?"></a>4、Vuex 是什么?</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>(1) 、解决了什么问题？</p>
<ul>
<li><p>多个视图依赖于同一状态。</p>
</li>
<li><p>来自不同视图的行为需要变更同一状态。</p>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
<p>(2)、实践<br>store/index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; import * as actions from &#39;.&#x2F;actions&#39;</span><br><span class="line">import * as getters from &#39;.&#x2F;getters&#39;</span><br><span class="line">import state from &#39;.&#x2F;state&#39;</span><br><span class="line">import mutations from &#39;.&#x2F;mutations&#39;</span><br><span class="line">import createLogger from &#39;vuex&#x2F;dist&#x2F;logger&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const debug &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    getters,</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    strict: debug,</span><br><span class="line">    plugins: debug ? [createLogger()] : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>store.getters.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const singer &#x3D; state &#x3D;&gt; state.singer</span><br></pre></td></tr></table></figure>
<p>mutation-types.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const SET_SINGER &#x3D; &#39;SET_SINGER&#39;</span><br></pre></td></tr></table></figure>
<p>mutation.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as types from &#39;.&#x2F;mutation-types&#39;</span><br><span class="line"></span><br><span class="line">const mutations &#x3D; &#123;</span><br><span class="line">    [types.SET_SINGER](state, singer) &#123;</span><br><span class="line">        state.singer &#x3D; singer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>
<p>state.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const state &#x3D; &#123;</span><br><span class="line">    singer: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>
<p>main.js中进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  render: h &#x3D;&gt; h(App),</span><br><span class="line">  store,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>singer.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapMutations&#125; from &#39;vuex&#39;</span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">    _initSingerList () &#123;</span><br><span class="line">      getSingerList().then(res &#x3D;&gt; &#123;</span><br><span class="line">        let list &#x3D; res.singerList.data.singerlist || [];</span><br><span class="line">        const singerList &#x3D; []</span><br><span class="line">        list.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">          let obj &#x3D; new Singer(item.singer_id, item.singer_name, item.singer_pic)</span><br><span class="line">          singerList.push(obj)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.singerList &#x3D; singerList;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    selectSinger (singer) &#123;</span><br><span class="line">      this.$router.push(&#123;</span><br><span class="line">        path: &#96;&#x2F;singer&#x2F;$&#123;singer.id&#125;&#96;</span><br><span class="line">      &#125;)</span><br><span class="line">      this.setSinger(singer)</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      setSinger: &#39;SET_SINGER&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>store/singer-detail.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#39;vuex&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapGetters([&#39;singer&#39;])</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        debugger</span><br><span class="line">        console.log(this.singer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/24/vue-924/" data-id="ckg6i8w4h0000mgl2a32dc5dw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-920" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/vue-920/" class="article-date">
  <time datetime="2020-09-21T06:11:20.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/vue-920/">vue-920</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、JSONP原理"><a href="#1、JSONP原理" class="headerlink" title="1、JSONP原理"></a>1、JSONP原理</h4><p>可以通过scripts跨域请求，其思路：生成一个script标签,传入一个回调名称，如jsonpCallback=’jsonpCBKD’，绑定在window对象上，待接口返回结果，会去调window.jsonpCBKD函数，再把数据送出去( <a href="https://github.com/webmodules/jsonp" target="_blank" rel="noopener">JSONP</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Module dependencies</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">var debug &#x3D; require(&#39;debug&#39;)(&#39;jsonp&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Module exports.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Callback index.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Noop function.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function noop()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * JSONP handler</span><br><span class="line"> *</span><br><span class="line"> * Options:</span><br><span class="line"> *  - param &#123;String&#125; qs parameter (&#96;callback&#96;)</span><br><span class="line"> *  - prefix &#123;String&#125; qs parameter (&#96;__jp&#96;)</span><br><span class="line"> *  - name &#123;String&#125; qs parameter (&#96;prefix&#96; + incr)</span><br><span class="line"> *  - timeout &#123;Number&#125; how long after a timeout error is emitted (&#96;60000&#96;)</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;String&#125; url</span><br><span class="line"> * @param &#123;Object|Function&#125; optional options &#x2F; callback</span><br><span class="line"> * @param &#123;Function&#125; optional callback</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function jsonp(url, opts, fn)&#123;</span><br><span class="line">  if (&#39;function&#39; &#x3D;&#x3D; typeof opts) &#123;</span><br><span class="line">    fn &#x3D; opts;</span><br><span class="line">    opts &#x3D; &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!opts) opts &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var prefix &#x3D; opts.prefix || &#39;__jp&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; use the callback name that was passed if one was provided.</span><br><span class="line">  &#x2F;&#x2F; otherwise generate a unique name by incrementing our counter.</span><br><span class="line">  &#x2F;&#x2F; 绑定在window对象上的函数名称</span><br><span class="line">  var id &#x3D; opts.name || (prefix + (count++));</span><br><span class="line">  &#x2F;&#x2F; 参数名称</span><br><span class="line">  var param &#x3D; opts.param || &#39;callback&#39;;</span><br><span class="line">  var timeout &#x3D; null !&#x3D; opts.timeout ? opts.timeout : 60000;</span><br><span class="line">  var enc &#x3D; encodeURIComponent;</span><br><span class="line">  var target &#x3D; document.getElementsByTagName(&#39;script&#39;)[0] || document.head;</span><br><span class="line">  var script;</span><br><span class="line">  var timer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (timeout) &#123;</span><br><span class="line">    timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">      cleanup();</span><br><span class="line">      if (fn) fn(new Error(&#39;Timeout&#39;));</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function cleanup()&#123;</span><br><span class="line">    if (script.parentNode) script.parentNode.removeChild(script);</span><br><span class="line">    window[id] &#x3D; noop;</span><br><span class="line">    if (timer) clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function cancel()&#123;</span><br><span class="line">    if (window[id]) &#123;</span><br><span class="line">      cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  window[id] &#x3D; function(data)&#123;</span><br><span class="line">    debug(&#39;jsonp got&#39;, data);</span><br><span class="line">    cleanup();</span><br><span class="line">    if (fn) fn(null, data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; add qs component</span><br><span class="line">  url +&#x3D; (~url.indexOf(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;) + param + &#39;&#x3D;&#39; + enc(id);</span><br><span class="line">  url &#x3D; url.replace(&#39;?&amp;&#39;, &#39;?&#39;);</span><br><span class="line"></span><br><span class="line">  debug(&#39;jsonp req &quot;%s&quot;&#39;, url);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; create script</span><br><span class="line">  script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.src &#x3D; url;</span><br><span class="line">  target.parentNode.insertBefore(script, target);</span><br></pre></td></tr></table></figure>

<h4 id="2、JSONP封装调用"><a href="#2、JSONP封装调用" class="headerlink" title="2、JSONP封装调用"></a>2、JSONP封装调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import OriginJsonp from &#39;jsonp&#39;</span><br><span class="line"></span><br><span class="line">export default function jsonp (url, data, option) &#123;</span><br><span class="line">    url +&#x3D; (url.indexOf(&#39;?&#39;) &lt; 0 ? &#39;?&#39; : &#39;&amp;&#39;) + param(data);</span><br><span class="line">    url &#x3D; url.replace(&#39;?&amp;&#39;,&#39;?&#39;)</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        OriginJsonp(url, option, (err, info) &#x3D;&gt; &#123;</span><br><span class="line">            if (!err) &#123;</span><br><span class="line">                resolve(info)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;) </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function param(params) &#123;</span><br><span class="line">    let paramTemp &#x3D; &#39;&#39;</span><br><span class="line">    for (let k in params) &#123;</span><br><span class="line">        paramTemp +&#x3D; &#96;&amp;$&#123;k&#125;&#x3D;$&#123;params[k] !&#x3D; &#39;undefined&#39; ? encodeURIComponent(params[k]) : &#39;&#39;&#125;&#96;</span><br><span class="line">    &#125;</span><br><span class="line">    return paramTemp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、keep-alive"><a href="#3、keep-alive" class="headerlink" title="3、keep-alive"></a>3、keep-alive</h4><p>在路由切换时，切换的组件又会重新加载，解决方法：可以在router-view外层加上keep-alive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>被keep-alive包裹的组件中，会多出两个生命周期钩子： activated和deactivated</p>
<ul>
<li>activated:在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。(第一次进入缓存路由/组件，在mounted后面)</li>
<li>deactivated：组件被停用(离开路由)时调用,使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/21/vue-920/" data-id="ckfera4990000e3l2689l5kwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-918" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/18/vue-918/" class="article-date">
  <time datetime="2020-09-18T02:36:30.000Z" itemprop="datePublished">2020-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/18/vue-918/">vue-918</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、初始化目录"><a href="#1、初始化目录" class="headerlink" title="1、初始化目录"></a>1、初始化目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack 文件名称</span><br></pre></td></tr></table></figure>


<h4 id="2、样式文件"><a href="#2、样式文件" class="headerlink" title="2、样式文件"></a>2、样式文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;.&#x2F;reset.styl&quot;</span><br><span class="line">@import &quot;.&#x2F;base.styl&quot;</span><br><span class="line">@import &quot;.&#x2F;icon.styl&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>variable.styl中放置页面中用到颜色和字体大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 颜色定义规范</span><br><span class="line">$color-background &#x3D; #222</span><br><span class="line">$color-background-d &#x3D; rgba(0, 0, 0, 0.3)</span><br><span class="line">$color-highlight-background &#x3D; #333</span><br><span class="line">$color-dialog-background &#x3D; #666</span><br><span class="line">$color-theme &#x3D; #ffcd32</span><br><span class="line">$color-theme-d &#x3D; rgba(255, 205, 49, 0.5)</span><br><span class="line">$color-sub-theme &#x3D; #d93f30</span><br><span class="line">$color-text &#x3D; #fff</span><br><span class="line">$color-text-d &#x3D; rgba(255, 255, 255, 0.3)</span><br><span class="line">$color-text-l &#x3D; rgba(255, 255, 255, 0.5)</span><br><span class="line">$color-text-ll &#x3D; rgba(255, 255, 255, 0.8)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字体定义规范</span><br><span class="line">$font-size-small-s &#x3D; 10px</span><br><span class="line">$font-size-small &#x3D; 12px</span><br><span class="line">$font-size-medium &#x3D; 14px</span><br><span class="line">$font-size-medium-x &#x3D; 16px</span><br><span class="line">$font-size-large &#x3D; 18px</span><br><span class="line">$font-size-large-x &#x3D; 22px</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、组件格式"><a href="#3、组件格式" class="headerlink" title="3、组件格式"></a>3、组件格式</h4><ul>
<li>html得有一个根元素包裹<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;排行页面&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;stylus&quot; rel&#x3D;&quot;stylesheet&#x2F;stylus&quot;&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、引入文件可以用绝对路径"><a href="#4、引入文件可以用绝对路径" class="headerlink" title="4、引入文件可以用绝对路径"></a>4、引入文件可以用绝对路径</h4><ul>
<li>在main.js中，可以这么引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;common&#x2F;stylus&#x2F;index.styl&#39;</span><br></pre></td></tr></table></figure></li>
<li>这是因为build/webpack.base.conf.js中配置了路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, &#39;..&#39;, dir)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">alias: &#123;</span><br><span class="line">      &#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">      &#39;common&#39;: resolve(&#39;src&#x2F;common&#39;),</span><br><span class="line">      &#39;components&#39;: resolve(&#39;src&#x2F;components&#39;),</span><br><span class="line">      &#39;base&#39;: resolve(&#39;src&#x2F;base&#39;),</span><br><span class="line">      &#39;api&#39;: resolve(&#39;src&#x2F;api&#39;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5、-vue文件中引入组件"><a href="#5、-vue文件中引入组件" class="headerlink" title="5、.vue文件中引入组件"></a>5、.vue文件中引入组件</h4><ul>
<li>组件引入时名称是大写，template中要小写，两个大写字母相连，可用’-‘连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;m-header &#x2F;&gt;</span><br><span class="line">    &lt;tab &#x2F;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;</span><br><span class="line">import MHeader from &#39;components&#x2F;m-header&#x2F;m-header&#39;</span><br><span class="line">import Tab from &#39;components&#x2F;tab&#x2F;tab&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MHeader,</span><br><span class="line">    Tab</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6、路由router"><a href="#6、路由router" class="headerlink" title="6、路由router"></a>6、路由router</h4><ul>
<li>router/index.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">import Recommend from &#39;components&#x2F;recommend&#x2F;recommend&#39;</span><br><span class="line">import Rank from &#39;components&#x2F;rank&#x2F;rank&#39;</span><br><span class="line">import Search from &#39;components&#x2F;search&#x2F;search&#39;</span><br><span class="line">import Singer from &#39;components&#x2F;singer&#x2F;singer&#39;</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      &#x2F;&#x2F; 默认情况下展示某个页面</span><br><span class="line">      redirect: &#39;&#x2F;recommend&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;recommend&#39;,</span><br><span class="line">      &#x2F;&#x2F; 这里是component,不是components</span><br><span class="line">      component: Recommend</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;rank&#39;,</span><br><span class="line">      component: Rank</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;search&#39;,</span><br><span class="line">      component: Search</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;singer&#39;,</span><br><span class="line">      component: Singer</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>main.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    render: h&#x3D;&gt; h(App),</span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>App.vue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;m-header &#x2F;&gt;</span><br><span class="line">    &lt;tab &#x2F;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li>
<li>tab.vue<br><em>router-link中tag是指用指定元素包裹，to是指点击的时候跳到相应的页面，每当点击某个按钮时，会自动添加router-link-actived的类名</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line">        &lt;router-link tag&#x3D;&quot;div&quot; class&#x3D;&quot;tab-item&quot; to&#x3D;&#39;&#x2F;recommend&#39;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;tab-link&quot;&gt;推荐&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-link tag&#x3D;&quot;div&quot; class&#x3D;&quot;tab-item&quot; to&#x3D;&quot;&#x2F;singer&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;tab-link&quot;&gt;歌手&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-link tag&#x3D;&quot;div&quot; class&#x3D;&quot;tab-item&quot; to&#x3D;&quot;&#x2F;rank&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;tab-link&quot;&gt;排行&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">        &lt;router-link tag&#x3D;&quot;div&quot; class&#x3D;&quot;tab-item&quot; to&#x3D;&quot;&#x2F;search&quot;&gt;</span><br><span class="line">            &lt;span class&#x3D;&quot;tab-link&quot;&gt;搜索&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped lang&#x3D;&quot;stylus&quot; rel&#x3D;&quot;stylesheet&#x2F;stylus&quot;&gt;</span><br><span class="line">  @import &quot;~common&#x2F;stylus&#x2F;variable&quot;</span><br><span class="line">  .tab</span><br><span class="line">    display: flex</span><br><span class="line">    height: 44px</span><br><span class="line">    line-height: 44px</span><br><span class="line">    font-size: $font-size-medium</span><br><span class="line">    .tab-item</span><br><span class="line">      flex: 1</span><br><span class="line">      text-align: center</span><br><span class="line">      .tab-link</span><br><span class="line">        padding-bottom: 5px</span><br><span class="line">        color: $color-text-l</span><br><span class="line">      &amp;.router-link-active</span><br><span class="line">        .tab-link</span><br><span class="line">          color: $color-theme</span><br><span class="line">          border-bottom: 2px solid $color-theme</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/18/vue-918/" data-id="ckfbymibi00003nl211zu3sbi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-day8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/07/webpack-day8/" class="article-date">
  <time datetime="2020-08-07T01:38:12.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/07/webpack-day8/">webpack-day8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、webpack启动过程分析"><a href="#1、webpack启动过程分析" class="headerlink" title="1、webpack启动过程分析"></a>1、webpack启动过程分析</h4><ol>
<li>开始：从webpack命令行说起<br>通过npm scripts运行webpack</li>
</ol>
<ul>
<li>开发环境：npm run dev</li>
<li>生产环境：npm run build</li>
</ul>
<ol start="2">
<li><p>通过webpack直接运行<br>webpack entry.js bundle.js // 查找入口文件并打包成bundle.js</p>
</li>
<li><p>查找webpack入口文件<br>在命令行运行以上命令后，npm 会让命令行工具进入node_modules.bin目录查找是否存在webpack.sh或者webpack.cmd文件，如果存在就执行，如果不存在就报错<br>实际的入口文件是：node_modules/webpack/bin/webpack.js<br>(webpack下的package.json中配置了bin字段)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;bin&#x2F;webpack.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析入口文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.exitCode &#x3D; 0; &#x2F;&#x2F; 1.正常执行返回</span><br><span class="line">const runCommand &#x3D; (command, args) &#x3D;&gt; &#123;...&#125; &#x2F;&#x2F; 2.运行某个命令</span><br><span class="line">const isInstalled &#x3D; packageName &#x3D;&gt; &#123;...&#125; &#x2F;&#x2F; 3.判断某个包是否安装</span><br><span class="line">const CLIs &#x3D; [...] &#x2F;&#x2F; 4.webpack可用的cli: webpack-cli 和 webpack-command</span><br><span class="line">const installedClis &#x3D; CLIs.filter(cli &#x3D;&gt; cli.installed); &#x2F;&#x2F; 5. 判断2个cli是否安装了</span><br><span class="line">if (installedClis.length &#x3D;&#x3D;&#x3D; 0) &#123;...&#125;else if (installedClis.length &#x3D;&#x3D;&#x3D; 1) &#123;...&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2、webpack-cli源码阅读"><a href="#2、webpack-cli源码阅读" class="headerlink" title="2、webpack-cli源码阅读"></a>2、webpack-cli源码阅读</h4><ol>
<li><p>webpack-cli做的事情<br>引入yargs,对命令行进行定制<br>分析命令行参数,对各个参数进行转换,组成编译配置项<br>引用webpack,根据配置项进行编译和构建</p>
</li>
<li><p>从NON_COMPILATION_CMD分析出不需要编译的命令<br>webpack-cli处理不需要经过编译的命令(即不需要实例化webpack对象)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123;NON_COMPILATION_ARGS&#125; &#x3D; require(&#39;.&#x2F;utils&#x2F;constants&#39;);</span><br><span class="line">const NON_COMPILATION_CMD &#x3D; process.argv.find(arg &#x3D;&gt; &#123;</span><br><span class="line">		if (arg &#x3D;&#x3D;&#x3D; &quot;serve&quot;) &#123;</span><br><span class="line">			global.process.argv &#x3D; global.process.argv.filter(a &#x3D;&gt; a !&#x3D;&#x3D; &quot;serve&quot;);</span><br><span class="line">			process.argv &#x3D; global.process.argv;</span><br><span class="line">		&#125;</span><br><span class="line">		return NON_COMPILATION_ARGS.find(a &#x3D;&gt; a &#x3D;&#x3D;&#x3D; arg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (NON_COMPILATION_CMD) &#123;</span><br><span class="line">		return require(&quot;.&#x2F;utils&#x2F;prompt-command&quot;)(NON_COMPILATION_CMD, ...process.argv);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NON_COMPILATION_ARGS的内容<br>webpack-cli提供的不需要编译的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const NON_COMPILATION_ARGS &#x3D; [</span><br><span class="line">  &quot;init&quot;,  &#x2F;&#x2F; 创建一份webpack配置文件</span><br><span class="line">  &quot;migrate&quot;,  &#x2F;&#x2F; 进行webpack版本迁移</span><br><span class="line">  &quot;add&quot;,    &#x2F;&#x2F; 往webpack配置文件中增加属性</span><br><span class="line">  &quot;remove&quot;,    &#x2F;&#x2F; 往webpack配置文件中删除属性</span><br><span class="line">  &quot;serve&quot;,    &#x2F;&#x2F; 运行webpack-serve</span><br><span class="line">  &quot;generate-loader&quot;, &#x2F;&#x2F; 生成webpack loader代码</span><br><span class="line">  &quot;generate-plugin&quot;, &#x2F;&#x2F; 生成webpack plugin代码</span><br><span class="line">  &quot;info&quot; &#x2F;&#x2F; 返回与本地环境相关的一些信息</span><br><span class="line">  ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行工具包yargs介绍<br>提供命令和分组参数<br>可以执行./node_modules/.bin/webpack help看下</p>
</li>
<li><p>webpack-cli使用args分析<br>参数分组(config/config-yargs.js),将命令划分为9类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Config options: 配置相关参数(文件名称、运行环境等)</span><br><span class="line">Basic options: 基础参数(entry设置、debug模式设置、watch监听设置、devtool设置)</span><br><span class="line">Module options: 模块参数，给loader设置扩展</span><br><span class="line">Output options: 输出参数(输出路径、输出文件名称)</span><br><span class="line">Advanced options: 高级用法(记录设置、缓存设置、监听频率、bail等)</span><br><span class="line">Resolving options: 解析参数(alias和解析的文件后缀设置)</span><br><span class="line">Optimizing options: 优化参数</span><br><span class="line">Stats options: 统计参数</span><br><span class="line">options: 通用参数(帮助命令、版本信息等)</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack-cli执行的结果<br>webpack对配置文件和命令行参数进行转换最终生成配置选项参数options<br>最终会根据配置参数实例化webpack对象,然后执行构建流程</p>
</li>
</ol>
<h4 id="3-Tapable插件结构与Hooks设计"><a href="#3-Tapable插件结构与Hooks设计" class="headerlink" title="3. Tapable插件结构与Hooks设计"></a>3. Tapable插件结构与Hooks设计</h4><ol>
<li><p>webpack的本质<br>webpack可以将其理解是一种基于事件流的编程范例，一系列的插件运行</p>
</li>
<li><p>node_modules/webpack/bin/webpack.js中引入了compiler,compiler中又引入了Compilation对象，而这两个对象都继承了Tapable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 核心对象Compiler继承Tapable</span><br><span class="line">class Compiler extends Tapable &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 核心对象Compilation继承Tapable</span><br><span class="line">class Compilation extends Tapable &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tapable是什么？<br>Tapable是一个类似于Node.js的eventEmiter的库,主要是控制钩子函数的发布与订阅,控制着webpack的插件系统<br>Tapable库暴露了很多Hook(钩子)类,为插件提供挂载的钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  SyncHook, &#x2F;&#x2F; 同步钩子</span><br><span class="line">  SyncBailHook, &#x2F;&#x2F; 同步熔断钩子</span><br><span class="line">  SyncWaterfallHook, &#x2F;&#x2F; 同步流水钩子</span><br><span class="line">  SyncLoopHook, &#x2F;&#x2F; 同步循环钩子</span><br><span class="line">  AsyncParallelHook, &#x2F;&#x2F; 异步并发钩子</span><br><span class="line">  AsyncParallelBailHook, &#x2F;&#x2F; 异步并发熔断钩子</span><br><span class="line">  AsyncSeriesHook, &#x2F;&#x2F; 异步串行钩子</span><br><span class="line">  AsyncSeriesBailHook, &#x2F;&#x2F; 异步串行熔断钩子</span><br><span class="line">  AsyncSeriesWaterfallHook, &#x2F;&#x2F; 异步串行流水钩子</span><br><span class="line">&#125; &#x3D; require(&#39;Tapable&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tapable hooks类型</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Type</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>Hook</td>
<td>所有类型的后缀</td>
</tr>
<tr>
<td>Waterfall</td>
<td>同步方法,但是它会传值给下一个函数</td>
</tr>
<tr>
<td>Bail</td>
<td>熔断： 当函数有任何返回值,就会在当前执行函数停止</td>
</tr>
<tr>
<td>Loop</td>
<td>监听函数返回true表示继续循环,返回undefined表示结束循环</td>
</tr>
<tr>
<td>Sync</td>
<td>同步方法</td>
</tr>
<tr>
<td>AsyncSeries</td>
<td>异步串行钩子</td>
</tr>
<tr>
<td>AsyncParallel</td>
<td>异步并行钩子</td>
</tr>
</tbody></table>
<ol start="5">
<li><p>Tapable的使用-new Hook新建钩子<br>Tapable暴露出来的都是类方法，new 一个类方法获得我们需要的钩子<br>class接受数组参数options，非必传。类方法会根据传参，接受同样数量的参数。<br>const hook1 = new SyncHook([‘args1’, ‘args2’, ‘args3’])</p>
</li>
<li><p>Tapable的使用-钩子的绑定与执行<br>Tapable提供了同步&amp;异步绑定钩子的方法，并且他们都有绑定事件和执行事件对应的方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Async *</th>
<th>sync *</th>
</tr>
</thead>
<tbody><tr>
<td>绑定:tapAsync/tapPromise/tap</td>
<td>绑定: tap</td>
</tr>
<tr>
<td>执行：callAsync/call</td>
<td>执行：call</td>
</tr>
</tbody></table>
<ol start="7">
<li><p>Tapable的使用-hook基本用法示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const hook1 &#x3D; new SyncHook([&#39;args1&#39;, &#39;args2&#39;, &#39;args3&#39;]);</span><br><span class="line">&#x2F;&#x2F; 绑定事件到webpack事件流</span><br><span class="line">hook1.tap(&#39;hook1&#39;, (args1, arg2, arg3) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(args1, arg2, arg3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行绑定的事件</span><br><span class="line">hook1.call(1,2,3)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tapable的使用-实际例子演示<br>定义一个Car方法,在内部Hooks上新建钩子。分别是同步钩子accelerate、brake(accelerate接受一个参数)、异步钩子caculateRoutes<br>使用钩子对应的绑定和执行方法<br>caculateRoutes使用tapPromise可以返回一个Promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">    SyncHook,</span><br><span class="line">    AsyncSeriesHook</span><br><span class="line">&#125; &#x3D; require(&#39;tapable&#39;);</span><br><span class="line"></span><br><span class="line">class Car &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.hooks &#x3D; &#123;</span><br><span class="line">            accelerate: new SyncHook([&#39;newspeed&#39;]),</span><br><span class="line">            brake: new SyncHook(),</span><br><span class="line">            caculateRoutes: new AsyncSeriesHook([&#39;source&#39;, &#39;target&#39;, &#39;routes&#39;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myCar &#x3D; new Car();</span><br><span class="line"></span><br><span class="line">myCar.hooks.brake.tap(&#39;warningLampPlugin&#39;, ()&#x3D;&gt; console.log(&#39;warningLampPlugin&#39;));</span><br><span class="line">myCar.hooks.accelerate.tap(&#39;loggerPlugin&#39;, newSpeed &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;Accelerating to $&#123;newSpeed&#125;&#96;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myCar.hooks.caculateRoutes.tapPromise(&#39;caculateRoutes tapPromise&#39;, (source, target, routeList, callback) &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;tapPromise to $&#123;source&#125; $&#123;target&#125; $&#123;routeList&#125;&#96;);</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myCar.hooks.brake.call();</span><br><span class="line">myCar.hooks.accelerate.call(10);</span><br><span class="line"></span><br><span class="line">myCar.hooks.caculateRoutes.promise(&#39;Async&#39;, &#39;hook&#39;, &#39;demo&#39;).then(()&#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;cost&#39;);</span><br><span class="line">&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    console.timeEnd(&#39;cost&#39;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="4、Tapable是如何和webpack进行关联起来的"><a href="#4、Tapable是如何和webpack进行关联起来的" class="headerlink" title="4、Tapable是如何和webpack进行关联起来的"></a>4、Tapable是如何和webpack进行关联起来的</h4><ol>
<li>原理：plugin监听hooks,compiler执行hook<br>compiler.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">    SyncHook,</span><br><span class="line">    AsyncSeriesHook</span><br><span class="line">&#125; &#x3D; require(&#39;tapable&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; class Compiler &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.hooks &#x3D; &#123;</span><br><span class="line">            accelerate: new SyncHook([&#39;newspeed&#39;]),</span><br><span class="line">            brake: new SyncHook(),</span><br><span class="line">            caculateRoutes: new AsyncSeriesHook([&#39;source&#39;, &#39;target&#39;, &#39;routes&#39;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    run () &#123;</span><br><span class="line">        this.accelerate(10);</span><br><span class="line">        this.brake()</span><br><span class="line">        this.caculateRoutes(&#39;Async&#39;, &#39;hook&#39;, &#39;demo&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accelerate (speed) &#123;</span><br><span class="line">        this.hooks.accelerate.call(speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    brake () &#123;</span><br><span class="line">        this.hooks.brake.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    caculateRoutes () &#123;</span><br><span class="line">        this.hooks.caculateRoutes.promise(...arguments).then(()&#x3D;&gt; &#123;</span><br><span class="line">        &#125;, err &#x3D;&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
my-plugin.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const Compiler &#x3D; require(&#39;.&#x2F;compiler.js&#39;);</span><br><span class="line"></span><br><span class="line">class Myplugin &#123;</span><br><span class="line">    constructor ()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 监听hook</span><br><span class="line">        compiler.hooks.brake.tap(&#39;warningLampPlugin&#39;, ()&#x3D;&gt; console.log(&#39;warningLampPlugin&#39;));</span><br><span class="line">        compiler.hooks.accelerate.tap(&#39;loggerPlugin&#39;, newSpeed &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;Accelerating to $&#123;newSpeed&#125;&#96;)</span><br><span class="line">        &#125;)</span><br><span class="line">        compiler.hooks.caculateRoutes.tapPromise(&#39;caculateRoutes tapPromise&#39;, (source, target, routeList, callback) &#x3D;&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">                setTimeout(()&#x3D;&gt; &#123;</span><br><span class="line">                    console.log(&#96;tapPromise to $&#123;source&#125; $&#123;target&#125; $&#123;routeList&#125;&#96;);</span><br><span class="line">                    resolve()</span><br><span class="line">                &#125;, 1000)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myPlugin &#x3D; new Myplugin();</span><br><span class="line"></span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">    plugins: [ myPlugin ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const compiler &#x3D; new Compiler();</span><br><span class="line"></span><br><span class="line">for(let plugin of options.plugins) &#123;</span><br><span class="line">    if (typeof plugin &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        plugin.call(compiler, compiler)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        plugin.apply(compiler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compiler.run();</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/07/webpack-day8/" data-id="ckdtu9b190000m8l28ado7tny" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-day7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/webpack-day7/" class="article-date">
  <time datetime="2020-07-28T08:43:08.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/28/webpack-day7/">webpack-day7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1、持续集成和Travis-CI"><a href="#1、持续集成和Travis-CI" class="headerlink" title="1、持续集成和Travis CI"></a>1、持续集成和Travis CI</h4><ol>
<li><p>持续集成的作用<br>优点：快速发现错误;防止分支大幅偏离主干<br>核心措施：代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成</p>
</li>
<li><p>接入Travis CI(commit的时候会自动触发ci功能，ci会触发.travis.yml)<br>(1) <a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> 使用github账号登录<br>(2) 在<a href="https://travis-ci.org/account/respositories" target="_blank" rel="noopener">https://travis-ci.org/account/respositories</a> 为项目开启<br>(3) 项目根目录下新增.travis.yml(配置文件)</p>
</li>
<li><p>travis.yml文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line"></span><br><span class="line">sudo: false</span><br><span class="line"></span><br><span class="line">cache: </span><br><span class="line">    apt: true,</span><br><span class="line">    directories:</span><br><span class="line">        - node_modules</span><br><span class="line">    </span><br><span class="line">    node_js: stable # 设置相应的版本</span><br><span class="line"></span><br><span class="line">    install:</span><br><span class="line">        - npm install -D # 安装构建器依赖</span><br><span class="line">        - cd .&#x2F;test&#x2F;template-project</span><br><span class="line">        - npm install -D # 安装模板项目依赖</span><br><span class="line">    script:</span><br><span class="line">        - npm test</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="2、发布构建包到npm社区"><a href="#2、发布构建包到npm社区" class="headerlink" title="2、发布构建包到npm社区"></a>2、发布构建包到npm社区</h4><ol>
<li>发布到npm </li>
</ol>
<ul>
<li>添加用户： npm adduser</li>
<li>升级版本<br>  升级补丁版本号： npm version patch<br>  升级小版本号： npm version minor<br>  升级大版本号： npm version major</li>
<li>发布版本: npm publish</li>
</ul>
<h4 id="3、Git-commit规范和changlog生成"><a href="#3、Git-commit规范和changlog生成" class="headerlink" title="3、Git commit规范和changlog生成"></a>3、Git commit规范和changlog生成</h4><ol>
<li>良好的Git commit 规范优势</li>
</ol>
<ul>
<li>加快Code review的流程</li>
<li>根据Git commit 的元数据生成Changelog</li>
<li>后续维护者可以知道Feature被修改的原因</li>
</ul>
<ol start="2">
<li>提交格式要求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>
对格式的说明如下：</li>
</ol>
<ul>
<li>type代表每次提交的类型<br>feat:新增feature<br>fix：修复bug<br>docs: 仅仅修改了文档<br>style: 仅仅修改了空格、缩进,不改变代码逻辑<br>refactor: 代码重构，没有加新功能或者修复bug<br>perf: 优化相关,比如提升性能、体验<br>test: 测试用例，包括单元测试、集成测试<br>chore: 改变构建流程、或者增加依赖库<br>revert: 回滚到上个版本</li>
</ul>
<ol start="3">
<li>本地开发阶段增加precommit钩子<br>1)、安装husky<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky -D</span><br></pre></td></tr></table></figure>
2)、通过commitMsg钩子校验信息</li>
</ol>
<h4 id="3、语义化版本规范格式"><a href="#3、语义化版本规范格式" class="headerlink" title="3、语义化版本规范格式"></a>3、语义化版本规范格式</h4><ol>
<li><p>开源项目版本信息案例<br>软件的版本通常由三位组成，X.Y.Z<br>版本是严格递增的<br>在发布重要版本时,可以发布alpha，rc等先行版本</p>
</li>
<li><p>语义化版本规范格式<br>主版本号: 当你做了不兼容的API更改<br>次版本号: 当你做了向下兼容的功能性新增<br>修订号：当你做了向下兼容的问题修正</p>
</li>
</ol>
<h4 id="4、初级分析-使用webpack内置的stats"><a href="#4、初级分析-使用webpack内置的stats" class="headerlink" title="4、初级分析:使用webpack内置的stats"></a>4、初级分析:使用webpack内置的stats</h4><p>stats: 构建的统计信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    &quot;build:stats&quot;: &quot;webpack --config webpack.prod.js --json &gt; stats.json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5、速度分析：-使用speed-measure-webpack-plugin"><a href="#5、速度分析：-使用speed-measure-webpack-plugin" class="headerlink" title="5、速度分析： 使用speed-measure-webpack-plugin"></a>5、速度分析： 使用speed-measure-webpack-plugin</h4><p>1、可以看到每个Loader和插件的耗时(npm i speed-measure-webpack-plugin -D)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const speedMeasureWebpackPlugin &#x3D; require(&#39;speed-measure-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">const smp &#x3D; new speedMeasureWebpackPlugin()</span><br><span class="line">module.exports &#x3D; smp.wrap(&#123;</span><br><span class="line">    entry: ...</span><br><span class="line">    output: ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="6、体积分析-使用wbpack-bundle-analyser"><a href="#6、体积分析-使用wbpack-bundle-analyser" class="headerlink" title="6、体积分析:使用wbpack-bundle-analyser"></a>6、体积分析:使用<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">wbpack-bundle-analyser</a></h4><ol>
<li><p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">        new BundleAnalyzerPlugin();</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行后npm run build，会打开<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a> , 可以查看各个部分的大小</p>
</li>
</ol>
<h4 id="7、多进程-多实例构建"><a href="#7、多进程-多实例构建" class="headerlink" title="7、多进程/多实例构建"></a>7、多进程/多实例构建</h4><ol>
<li><p>资源并行解析可选方案<br>happypack/parallel-webpack/thread-loader</p>
</li>
<li><p>使用<a href="https://github.com/webpack-contrib/thread-loader" target="_blank" rel="noopener">thread-loader</a>解析资源<br>原理： 每次webpack解析一个模块,thread-loader会将它及它的依赖分配给worker线程中</p>
</li>
<li><p>happy-loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack &#x3D; require(&#39;happypack&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;.js$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#x2F;&#x2F; 1) replace your original list of loaders with &quot;happypack&#x2F;loader&quot;:</span><br><span class="line">                    &#39;happypack&#x2F;loader&#39;</span><br><span class="line">                ],</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: &#123;</span><br><span class="line">        &#x2F;&#x2F; 2) create the plugin:</span><br><span class="line">        new HappyPack(&#123;</span><br><span class="line">            3) re-add the loaders you replaced above in #1</span><br><span class="line">            loaders: [ &#39;babel-loader&#39; ] &#x2F;&#x2F; 这里loader是#1的loader</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一下（npm run build），竟然比不使用的时候花费时间更久，什么鬼噢<br>再来看看thread-loader</p>
</li>
<li><p>thread-loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    ...</span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                loader: &#39;thread-loader&#39;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                workers: 3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#39;babel-loader&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和happy-loader半斤八两，还不如不加</p>
</li>
</ol>
<h4 id="7、多进程并行压缩代码"><a href="#7、多进程并行压缩代码" class="headerlink" title="7、多进程并行压缩代码"></a>7、多进程并行压缩代码</h4><ol>
<li>并行压缩：terser-webapck-plugin开启parallel参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const TerserPlugin &#x3D; require(&#39;terser-webpack-plugin&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            new TerserPlugin(&#123;</span><br><span class="line">                parallel: true</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
测试之后，使用terser-webpack-plugin要快5ms</li>
</ol>
<h4 id="8、进一步分包：预编译资源模块"><a href="#8、进一步分包：预编译资源模块" class="headerlink" title="8、进一步分包：预编译资源模块"></a>8、进一步分包：预编译资源模块</h4><ol>
<li><p>分包:设置Externals<br>思路： 将react、react-dom基础包通过cdn引入，不打入bundle中(使用html-webpack-externals-plugin)<br>缺点：一个基础包须得指定一个cdn,包多了指定地址也会变多，导致html中也会引入多个script标签</p>
</li>
<li><p>进一步分包:预编译模块<br>思路：将react、react-dom、redux、react-redux基础包和业务基础包打包成一个文件<br>方法：使用webpack内置的DLLPlugin进行分包(即打包成一个文件，并生成一个manifest.json),DllReferencePlugin对manifest.json（这个文件是对打包生成的这个文件的描述）引用</p>
</li>
<li><p>使用DLLPlugin进行分包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        library: [</span><br><span class="line">            &#39;react&#39;,</span><br><span class="line">            &#39;react-dom&#39;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;[name]_[chunkhash].dll.js&#39;,</span><br><span class="line">        path: path.join(__dirname, &#39;build&#x2F;library&#39;),</span><br><span class="line">        library: &#39;[name]&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            name: &#39;[name]_[hash]&#39;,</span><br><span class="line">            path: path.join(__dirname, &#39;build&#x2F;library&#x2F;[name].json&#39;),</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用DllReferencePlugin引用manifest.json<br>在webpack.config.js引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: require(&#39;.&#x2F;build&#x2F;library&#x2F;manifest.json&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用效果：<br>打包好的html中通过script标签引入打包好的这个js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scripts src&#x3D;&quot;&#x2F;build&#x2F;library&#x2F;library.dll.js&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>想添加多个包，可以再加一个new webpack.DllReferencePlugin<br>验证了一下，使用dll,打包时间是2321ms,不使用是4688ms,打包速度提升了一半</p>
</li>
</ol>
<h4 id="9、充分利用缓存来实现二次构建速度"><a href="#9、充分利用缓存来实现二次构建速度" class="headerlink" title="9、充分利用缓存来实现二次构建速度"></a>9、充分利用缓存来实现二次构建速度</h4><ol>
<li><p>缓存思路<br>babel-loader开启缓存<br>代码压缩阶段terser-webpack-plugin开启缓存<br>使用cache-loader或者hard-source-webpack-plugin</p>
</li>
<li><p>判断有无缓存：看node_modules下是否有.cache文件</p>
</li>
<li><p>babel-loader和terser-webpack-plugin 虽然可以提升二次构建速度，但是提升不是太明显。相对来说，引入hard-sorce-webpack-plugin后，二次构建速度提升了好几倍</p>
</li>
<li><p>引用方法<br>1)、安装：<code>npm install --save-dev hard-source-webpack-plugin</code><br>2)、接入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var HardSourceWebpackPlugin &#x3D; require(&#39;hard-source-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  context: &#x2F;&#x2F; ...</span><br><span class="line">  entry: &#x2F;&#x2F; ...</span><br><span class="line">  output: &#x2F;&#x2F; ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new HardSourceWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10、缩小构建目标"><a href="#10、缩小构建目标" class="headerlink" title="10、缩小构建目标"></a>10、缩小构建目标</h4><ol>
<li><p>目的： 尽可能的少构建模块<br>比如：babel-loader不解析node_modules</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        loader: &#39;happypack&#x2F;loader&#39;,</span><br><span class="line">        exclude: &#39;node_modules&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>减少文件搜索范围<br>1)、 优化resolve.modules配置(减少模块搜索层级)：webpack打包时，会在node_modules中去检查我们依赖的模块有没有，没有的话会再往上一级目录的node_modules中去寻找，指定查找范围后，节省去寻找的时间<br>2）、优化resolve.mainFields配置: 打包时，会去找package.json中的main指定的入口文件，如果没有找到main字段，就会一层层往上找<br>3)、优化resolve.extensions配置：当我们import一个文件时，可以不写后缀，webpack会自动按照.js，接着.json等的文件进行查找，指定文件后缀名可以节约查询时间<br>4)、合理使用alias: 指定某个模块的依赖路径，不用webpack一层层去查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            react: path.resolve(__dirname,&#39;.&#x2F;node_modules&#x2F;react&#x2F;dist&#x2F;react.min.js&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        modules: [path.resolve(__dirname, &#39;node_modules&#39;)],</span><br><span class="line">        extensions: [&#39;.js&#39;],</span><br><span class="line">        mainFields: [&#39;main&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<h4 id="11、使用Tree-Shaking擦除无用的javascript和css"><a href="#11、使用Tree-Shaking擦除无用的javascript和css" class="headerlink" title="11、使用Tree Shaking擦除无用的javascript和css"></a>11、使用Tree Shaking擦除无用的javascript和css</h4><ol>
<li><p>tree shaking复习<br>概念： 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里面去，tree shaking 就是把用到的方法打入bundle,没用到的方法会在uglify阶段擦除掉<br>使用： webpack默认支持，在.babelrc里设置modules：false即可<br>production mode的情况下默认开启<br>要求： 必须是Es6的语法，cjs不支持</p>
</li>
<li><p>无用的css怎么擦除掉？<br>PurifyCSS:遍历代码，识别已经用到的Css class<br>uncss: Html需要通过jsDom加载,所有的样式通过PostCss解析，通过document.querySelector来识别在html文件里面不存在的选择器</p>
</li>
<li><p>在webpack中如何使用PurifyCss?<br>使用<a href="https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin" target="_blank" rel="noopener">purgecss-webpack-plugin</a><br>和mini-css-extract-plugin配合使用</p>
</li>
</ol>
<h4 id="12、使用webpack进行图片压缩"><a href="#12、使用webpack进行图片压缩" class="headerlink" title="12、使用webpack进行图片压缩"></a>12、使用webpack进行图片压缩</h4><ol>
<li>图片压缩<br>要求： 基于node库的imagemin或者tinypng API<br>使用： 配置<a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener">image-webpack-loader</a><br>之前都需要手动压缩，引入这个插件就方便了</li>
<li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            &#123;</span><br><span class="line">           test: &#x2F;.(png|jpg|gif|jpeg)$&#x2F;,</span><br><span class="line">           use: [</span><br><span class="line">           &#123;</span><br><span class="line">               loader: &#39;file-loader&#39;,</span><br><span class="line">               options: &#123;</span><br><span class="line">               name: &#39;[name]_[hash:8].[ext]&#39;,</span><br><span class="line">               &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               loader: &#39;image-webpack-loader&#39;,</span><br><span class="line">               options: &#123;</span><br><span class="line">               mozjpeg: &#123;</span><br><span class="line">                   progressive: true,</span><br><span class="line">                   quality: 65</span><br><span class="line">               &#125;,</span><br><span class="line">               &#x2F;&#x2F; optipng.enabled: false will disable optipng</span><br><span class="line">               optipng: &#123;</span><br><span class="line">                   enabled: false,</span><br><span class="line">               &#125;,</span><br><span class="line">               pngquant: &#123;</span><br><span class="line">                   quality: [0.65, 0.90],</span><br><span class="line">                   speed: 4</span><br><span class="line">               &#125;,</span><br><span class="line">               gifsicle: &#123;</span><br><span class="line">                   interlaced: false,</span><br><span class="line">               &#125;,</span><br><span class="line">               &#x2F;&#x2F; the webp option will enable WEBP</span><br><span class="line">               webp: &#123;</span><br><span class="line">                   quality: 75</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           ],</span><br><span class="line">           &#125;,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用后，压缩效果还是可以的，大小缩小了一半</li>
</ol>
<h4 id="13、使用动态polyfill服务"><a href="#13、使用动态polyfill服务" class="headerlink" title="13、使用动态polyfill服务"></a>13、使用动态polyfill服务</h4><p> 1、polyfill相当于腻子，填补一些不太光滑的地方</p>
<p> 2、根据user agennt来判断当前设备不支持哪些方法，从而进行下载<br> <a href="https://polyfill.io/v3/polyfill.min.js" target="_blank" rel="noopener">https://polyfill.io/v3/polyfill.min.js</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/webpack-day7/" data-id="ckdebmkgd000087xu5ncrfktk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/27/vue-print5/">vue-print5</a>
          </li>
        
          <li>
            <a href="/2020/10/26/vue-prin4/">vue-prin4</a>
          </li>
        
          <li>
            <a href="/2020/10/22/vue-prin3/">vue-prin3</a>
          </li>
        
          <li>
            <a href="/2020/10/21/vue-prin2/">vue-prin2</a>
          </li>
        
          <li>
            <a href="/2020/10/19/vue-prin1/">vue-prin1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>